package ch.ahdis.matchbox.validation.matchspark;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import ch.ahdis.matchbox.CliContext;
import ch.ahdis.matchbox.engine.cli.MatchboxCli;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import dev.langchain4j.data.message.SystemMessage;
import dev.langchain4j.data.message.UserMessage;
import dev.langchain4j.memory.ChatMemory;
import dev.langchain4j.memory.chat.MessageWindowChatMemory;
import dev.langchain4j.model.chat.ChatLanguageModel;
import dev.langchain4j.model.huggingface.HuggingFaceChatModel;
import dev.langchain4j.model.openai.OpenAiChatModel;
import dev.langchain4j.model.openai.OpenAiChatModelName;

import org.springframework.beans.factory.annotation.Value;

/**
 * The OpenAIConnector class is used to create the http-POST-request to OpenAI.
 * In order to create the request you need to define a model and an API-key (which is stored as an environment variable).
 * Four of the used prompts are displayed here as final strings.
 * Because there were 3 prototypes, a slightly different block of code for the respecting methods. There could be some refactoring done here.
 */
public class OpenAIConnector2 {

    // String names of two OpenAI LLMs used in this project.
    private static final String MODEL_OLD = "gpt-3.5-turbo";
    private static final String MODEL = "gpt-4o-mini";

    // The API-key used for the requests. Stored as an environment variable.
    //private static final String API_KEY = System.getenv("OPENAI_API_KEY");
    private static String LLM_PROVIDER;
    private static String MODEL_NAME;
    private static String API_KEY;

    // Four of the prompts used in this project.
    public static final String PROMPT1 = "You are an AI that helps analyze and interpret FHIR resources and their validation results." +
            "Focus on the issues with severity labeled 'fatal' or 'error' and only give a short summary about those error messages and a plan " +
            "how to fix those issues.";
    public static final String PROMPT2 = "You are an AI that helps analyze and interpret FHIR resources and their validation results. " +
            "Focus on the issues with severity labeled 'fatal' or 'error' and provide guidance for the underlying issues or what needs to be fixed.";
    public static final String PROMPT3 = "You are an AI that helps analyze and interpret FHIR resources and their validation results. " +
            "Focus on the issues with severity labeled 'fatal' or 'error' and provide guidance for the underlying issues or what needs to be fixed." +
            "If there are no issues labeled 'fatal' or 'error', simply reply with: 'The resource is valid'. Nothing more. Else: keep your answer as short as possible.";
    public static final String PROMPT4 = "You are an AI that helps analyze and interpret FHIR resources and their validation results. " +
            "Focus on the issues with severity labeled 'fatal' or 'error' and provide guidance for the underlying issues and examples of what needs to be fixed. If there are several errors generated by the same source, summarize them." +
            "If there are no issues labeled 'fatal' or 'error', simply reply with: 'The resource is valid'. Nothing more. Else: keep your answer as short as possible. Return your full answer in markdown format.";

    private final HttpClient httpClient;
    private final ObjectMapper objectMapper;
    private ChatLanguageModel model;
    private ChatMemory chatMemory;

    /**
     * Constructor for the OpenAIConnector.
     */
    public OpenAIConnector2(CliContext cliContext) {
        httpClient = HttpClient.newHttpClient();
        objectMapper = new ObjectMapper();
        LLM_PROVIDER = cliContext.getLlmProvider();
        MODEL_NAME = cliContext.getModelName();
        API_KEY = cliContext.getApiKey();
        initializeChatModel();
    }

    private void initializeChatModel() {
        chatMemory = MessageWindowChatMemory.builder()
            .id("12345")
            .maxMessages(10)
            .build();
        chatMemory.add(SystemMessage.from(PROMPT4));
        if (LLM_PROVIDER.equals("openai")) {
            model = OpenAiChatModel.builder()
                .apiKey(API_KEY)
                .modelName(MODEL_NAME)
                .build();
        } else if (LLM_PROVIDER.equals("huggingface")) {
            model = HuggingFaceChatModel.builder()
                .accessToken(API_KEY)
                .modelId(MODEL_NAME)
                .build();
        }
    }

    /**
     * Final Prototype: Interprets the result with a LLM of OpenAI. Uses a function called createRequestBody(). Gets input from GUI.
     * @param resource The string received from the Matchbox containing the FHIR resource.
     * @param operationOutcome The string received from the Matchbox containing the validation result (OperationOutcome).
     * @return The response string from the LLM.
     * @throws IOException          if an I/ O error occurs when sending or receiving
     * @throws InterruptedException if the operation is interrupted
     */
    public String interpretWithMatchbox(String resource, String operationOutcome) {
        if (API_KEY == null) {
            return "API Key not found. Please set the OPENAI_API_KEY environment variable.";
        }
        try {
            ObjectNode fhirResourceContent = (ObjectNode) objectMapper.readTree(resource);
            ObjectNode operationOutcomeContent = (ObjectNode) objectMapper.readTree(operationOutcome);
            String requestBody = createRequestBody(fhirResourceContent, operationOutcomeContent, objectMapper, PROMPT4);

            // write the whole LLM-Input-String to a File for later Tokenizer-analysis
            saveStringToFile(requestBody);

            //String response = model.chat(requestBody);
            chatMemory.add(UserMessage.from(requestBody));
            String response = model.chat(chatMemory.messages()).aiMessage().text();
            // Return the LLMs response
            return response.replace(requestBody, "").replace(PROMPT4, "").trim();

        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
            return e.getMessage();
        }
    }

    /**
     * Creates the request body for the LLM-request.
     * @param fhirResourceContent The ObjectNode received from calling method containing the FHIR resource.
     * @param operationOutcomeContent The ObjectNode received from the calling method containing the validation result (OperationOutcome).
     * @param objectMapper An ObjectMapper received to create the Json-structure of the request.
     * @param prompt A prompt to give the necessary instructions to the LLM.
     * @return The response string from the LLM.
     * @throws IOException          if an I/ O error occurs when sending or receiving
     * @throws InterruptedException if the operation is interrupted
     */
    private static String createRequestBody(ObjectNode fhirResourceContent, ObjectNode operationOutcomeContent, ObjectMapper objectMapper, String prompt)
            throws IOException, InterruptedException {

        // Create the root JSON object for the request payload
        ObjectNode jsonForRequest = objectMapper.createObjectNode();
        jsonForRequest.put("model", MODEL);

        ArrayNode messages = objectMapper.createArrayNode();

        // System message to set the context for the LLM
       /* ObjectNode systemMessage = objectMapper.createObjectNode();
        systemMessage.put("role", "system");
        systemMessage.put("content", prompt);
        messages.add(systemMessage);*/

        // User message for the FHIR resource
        ObjectNode resourceMessage = objectMapper.createObjectNode();
        resourceMessage.put("role", "user");
        resourceMessage.put("content", "Here is the FHIR resource: " + fhirResourceContent.toString());
        messages.add(resourceMessage);


        // User message for the validation result
        ObjectNode operationOutcomeMessage = objectMapper.createObjectNode();
        operationOutcomeMessage.put("role", "user");
        operationOutcomeMessage.put("content", "Here is the validation result: " + operationOutcomeContent.toString());
        messages.add(operationOutcomeMessage);

        // Add the messages array to the request payload
        jsonForRequest.set("messages", messages);

        // Add optional parameters
        jsonForRequest.put("max_tokens", 500);
        jsonForRequest.put("temperature", 1);

        String requestString = "Here is the FHIR resource: " + fhirResourceContent.toString() + "\n";
        requestString += "Here is the validation result: " + operationOutcomeContent.toString();

        // Convert the JSON payload to a string
        return requestString;
        //return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonForRequest);
    }

    /**
     * Simple method to save a String to a File. Used to save the LLM-Input to analyze the Nr. of tokens later.
     * @param str The given String.
     * @throws IOException          if an I/ O error occurs when sending or receiving
     */
    private void saveStringToFile(String str) throws IOException {
        // Get current date and time
        LocalDateTime now = LocalDateTime.now();

        // Format the date and time
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss");
        String timestamp = now.format(formatter);

        File file = File.createTempFile("Input", "_" + timestamp, new File("C:/Users/noaju/Dev/openai_data"));
        Path filePath = file.toPath();
        Files.write(filePath, str.getBytes());
    }
}
